<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>relm4-store</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-birth.html"><strong aria-hidden="true">1.1.</strong> How the data stores came to life</a></li><li class="chapter-item expanded "><a href="02-goals.html"><strong aria-hidden="true">1.2.</strong> Goals</a></li><li class="chapter-item expanded "><a href="03-relm4-vs-store.html"><strong aria-hidden="true">1.3.</strong> relm4 vs store</a></li><li class="chapter-item expanded "><a href="04-application_architecture.html"><strong aria-hidden="true">1.4.</strong> Application architecture</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/01-setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="examples/01-todo/index.html"><strong aria-hidden="true">2.2.</strong> Simple todo 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/01-todo/01-model.html"><strong aria-hidden="true">2.2.1.</strong> Model</a></li><li class="chapter-item expanded "><a href="examples/01-todo/02-store.html"><strong aria-hidden="true">2.2.2.</strong> Store</a></li><li class="chapter-item expanded "><a href="examples/01-todo/03-task_list.html"><strong aria-hidden="true">2.2.3.</strong> View - Task list</a></li><li class="chapter-item expanded "><a href="examples/01-todo/04-main_window.html"><strong aria-hidden="true">2.2.4.</strong> View - Main window</a></li><li class="chapter-item expanded "><a href="examples/01-todo/05-main.html"><strong aria-hidden="true">2.2.5.</strong> main</a></li><li class="chapter-item expanded "><a href="examples/01-todo/06-configuration.html"><strong aria-hidden="true">2.2.6.</strong> configuration</a></li></ol></li><li class="chapter-item expanded "><a href="examples/02-todo/index.html"><strong aria-hidden="true">2.3.</strong> Simple todo 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/02-todo/01-generate-tasks.html"><strong aria-hidden="true">2.3.1.</strong> Generating tasks</a></li><li class="chapter-item expanded "><a href="examples/02-todo/02-updating-store-view.html"><strong aria-hidden="true">2.3.2.</strong> Updating store view</a></li><li class="chapter-item expanded "><a href="examples/02-todo/03-updating_taks_list.html"><strong aria-hidden="true">2.3.3.</strong> Updating task list</a></li><li class="chapter-item expanded "><a href="examples/02-todo/04-configuration.html"><strong aria-hidden="true">2.3.4.</strong> configuration</a></li></ol></li><li class="chapter-item expanded "><a href="examples/03-todo/index.html"><strong aria-hidden="true">2.4.</strong> Simple todo 3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/03-todo/01-ordering.html"><strong aria-hidden="true">2.4.1.</strong> Ordering</a></li><li class="chapter-item expanded "><a href="examples/03-todo/02-custom_sorting.html"><strong aria-hidden="true">2.4.2.</strong> Custom sorting</a></li><li class="chapter-item expanded "><a href="examples/03-todo/03-view.html"><strong aria-hidden="true">2.4.3.</strong> View</a></li><li class="chapter-item expanded "><a href="examples/03-todo/04-configuration.html"><strong aria-hidden="true">2.4.4.</strong> configuration</a></li></ol></li><li class="chapter-item expanded "><a href="examples/04-todo/index.html"><strong aria-hidden="true">2.5.</strong> Simple todo 4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/04-todo/01-view.html"><strong aria-hidden="true">2.5.1.</strong> View</a></li><li class="chapter-item expanded "><a href="examples/04-todo/02-configuration.html"><strong aria-hidden="true">2.5.2.</strong> configuration</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="releases/index.html"><strong aria-hidden="true">3.</strong> Releases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="releases/0.1-beta.2.html"><strong aria-hidden="true">3.1.</strong> 0.1-beta.2</a></li><li class="chapter-item expanded "><a href="releases/0.1-beta.1.html"><strong aria-hidden="true">3.2.</strong> 0.1-beta.1</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">relm4-store</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stores-for-relm4"><a class="header" href="#stores-for-relm4">Stores for relm4</a></h1>
<p>This book introduces concept of stores and provides samples of usage in relm4 applications.</p>
<h2 id="what-is-store-and-why-do-i-need-it"><a class="header" href="#what-is-store-and-why-do-i-need-it">What is store and why do I need it?</a></h2>
<p><strong>Store is shared data collection</strong>. There are few benefits of using stores.</p>
<ol>
<li>It makes much easier to separate application business model and view.</li>
<li>It makes state propagation much easier.</li>
<li>It reduces the complexity of the applications.</li>
</ol>
<p>Other way of thinking about Store is as really simple database specialized in making relm4 applications easier to write.</p>
<h2 id="what-is-the-price-to-use-it"><a class="header" href="#what-is-the-price-to-use-it">What is the price to use it?</a></h2>
<p>Now it's pre-alpha state. So you shouldn't use it at all. :)</p>
<p>To tell the truth, the target is to make it possible to use it with minimum costs and integrate it as tightly to the relm4 as possible. Currently it's not trivial to use stores since many things are not completed.</p>
<h2 id="what-this-book-is-not-about"><a class="header" href="#what-this-book-is-not-about">What this book is not about?</a></h2>
<ul>
<li>It's not about <code>rust</code>. Examples consists of multiple files and you are expected to add <code>mod.rs</code> files with appropriate exports by yourself (or check the directory with example). On the other hand we did our best to make sure that any file which has more then module declarations and reexports will be documented here.</li>
<li>It's not about relm4. You won't learn how widget macro works or how events are propagated. We might talk a bit about that but only to make code presented here understandable.</li>
<li>You won't learn how to write your own store/relm4 factory from this book. Writing the store or relm4 factory is complex task. There is a plan to add a chapter about that, but it won't happen anywhere in the near future.</li>
<li>For the same reason as factories, StoreViews are also out of scope. Good for you we already provide some implementations.</li>
</ul>
<h2 id="how-to-read-the-book"><a class="header" href="#how-to-read-the-book">How to read the book</a></h2>
<p>There are two ways to read this book. First one is to follow the chapters in order. This will gently introduce you to all concepts required to use stores. Second way is to go directly to the part you are interested into. The examples in the book after chapter 1 are just the modifications of the code from previous chapter. Full code of examples you can find in the <code>examples folder</code>.</p>
<h3 id="window-behavior"><a class="header" href="#window-behavior">Window behavior</a></h3>
<ul>
<li><a href="./examples/03-todo/01-ordering.html">Description of window behavior</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-it-came-to-existence"><a class="header" href="#how-it-came-to-existence">How it came to existence</a></h1>
<p>It's mid of 2021. I've started to learn Rust for a second time. This time I had an idea for an internal project for my company. I needed to create an gui application.</p>
<p>I've found relm. I've started to learn it. Nice lib. Most people in company are linux/gnome users so gtk was perfect choice. But it was gtk-3 lib and gtk-4 was becoming a main version. After bit of looking around I found a relm4. Now I had a lib to write my application. So let's get started. 2 week later I was in pinch. I had a dataset weighting around 200GB, needed to show it twice, it must have a filtering and grouping. Filtering could be done either global (so both view were applied the same filter) or local so filters are independent or both. So I implemented first version of widget using provided relm4 factories. Doing it was a disaster. Ok. Attempt 2. Let's dive into gtk list views. Bit better. I could do most of things. But now let's repeat process for another data set, and another data set... Tears of blood. Now I received a requirement from one of the users. Scrollbar sucks. It doesn't provide any meaningful information about where user is. So let's just make them steer a speed of scroll (relative scrolling) instead of track position (absolute scrolling). Oh and I forgot. I would like to have an option to change a behavior of visible data if records are inserted in the visible sub set. Now I was sitting in the corner of my room. Crying. I'm the boss. I own this company. I've created a tool for myself. It sucks but makes it better then whatever was before and I only receive complaints... Ok it's useful. My workers just would like to spend a bit time less there. Let's try...</p>
<p>A few relm4 tickets later I knew lib good enough to start. And I ended with creating first version of store. It was even more primitive then any factory in relm4. It supported only adding elements at the end of the set but had an ability to ignore changes outside of visible window.</p>
<p>It's still at beginning of the journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goals-of-the-store-library"><a class="header" href="#goals-of-the-store-library">Goals of the store library</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
Window behavior on data changes
<ul>
<li><input disabled="" type="checkbox"/>
Window transitions
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Add new record</li>
<li><input disabled="" type="checkbox"/>
Slide/reorder</li>
<li><input disabled="" type="checkbox" checked=""/>
Remove</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
View follows transitions</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Relative scrolling</li>
<li><input disabled="" type="checkbox"/>
Sorting
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Setting natural order</li>
<li><input disabled="" type="checkbox"/>
Store view order</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Grouping</li>
<li><input disabled="" type="checkbox"/>
Trees</li>
<li><input disabled="" type="checkbox"/>
Implementation of basic store types
<ul>
<li><input disabled="" type="checkbox"/>
In memory store
<ul>
<li><input disabled="" type="checkbox"/>
Sorting
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Natural order</li>
<li><input disabled="" type="checkbox"/>
Store view order</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Http/rest store (as external crate)</li>
<li><input disabled="" type="checkbox"/>
Mongo store (as external crate)</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Detached view
<ul>
<li><input disabled="" type="checkbox"/>
Commit</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Filtering</li>
<li><input disabled="" type="checkbox"/>
Reusable components
<ul>
<li><input disabled="" type="checkbox"/>
Pagination component
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Basics</li>
<li><input disabled="" type="checkbox"/>
Make it configurable and generally awesome</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Pagination</li>
<li><input disabled="" type="checkbox" checked=""/>
View should care about records which are visible only</li>
<li><input disabled="" type="checkbox"/>
Generic view for the store
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Replaces relm4 factory</li>
<li><input disabled="" type="checkbox"/>
Event propagation to the listeners of the view</li>
</ul>
</li>
</ul>
<h2 id="missing-things"><a class="header" href="#missing-things">Missing things</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Reorder records, for now it triggers reload on the store</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relm4-vs-stores"><a class="header" href="#relm4-vs-stores">Relm4 vs stores</a></h1>
<p>Stores are extension to relm4 but they introduce a separation between a business model and view model.</p>
<p>When you learn relm4 you start by throwing whole application state into model. This model is tightly related to view. You are forced to mix the application code and view related updates.</p>
<p>Stores introduces strict separation of business model and view. So in this book whenever we talk about view model we literally mean structures implementing <code>relm4::Model</code>. All imports will be done as <code>use relm4::Model as ViewModel</code>. When we talk about model or business model we will think about structures implementing <code>relm4_store_record::Record</code>.</p>
<h2 id="what-is-a-benefit-of-this-separation"><a class="header" href="#what-is-a-benefit-of-this-separation">What is a benefit of this separation?</a></h2>
<p>Record has stable identifier. This provides a few benefits like:</p>
<ol>
<li>You know when you talk about same instance even if they are not binary equal.</li>
<li>Data becomes data and not the application state.</li>
</ol>
<p>Both points are interrelated but slightly nuanced. Let's start from second point.</p>
<h3 id="data-becomes-data"><a class="header" href="#data-becomes-data">Data becomes data</a></h3>
<p>This is point of view of data users. They don't care about the id itself. They care about the business logic.</p>
<p>Since you have a stable id, you perfectly know when you talk about the same record. So you can keep a cloned values of your model. Update them and later commit them back or drop them at your leisure. You don't need to track information like <code>it's fifth item on list of emails in 3 item in list of users</code>. Just think a bit how much code you would need to write if you must add a record into users and user emails while you have a copy of your data laying somewhere around and you must track this relationship. Since you have a stable id, user model can trivially provide update email logic for things like this.</p>
<h3 id="same-instance-even-when-not-binary-equal"><a class="header" href="#same-instance-even-when-not-binary-equal">Same instance even when not binary equal</a></h3>
<p>This is point of view of data management. If you receive a record in a store you know what to do with a record. It either exists in a store or it's something new. This information is stored in records id and not a complex logic of passing data around.</p>
<p>So your store is committing an instance of user. Now since your user has stable id, you know if this record was stored without even looking into whatever your store backend is. Either final id is set or not. Your whole logic around business doesn't care about id's values. Whatever they are they are. What's important is if they are set they are known for eternity.</p>
<p>What's more new id is not empty. It has a value, so if you store your record in the database, or file, or some other service you just need to propagate a tuple of new id, permanent id to the places you store a copy of your record without tracking the position, nesting, or any other extra information. Your model logic have a way to find it wherever it is since it needs to be able to retrieve it in running application.</p>
<h2 id="list-of-differences"><a class="header" href="#list-of-differences">List of differences</a></h2>
<table><thead><tr><th align="left">relm4-store</th><th align="left">relm4</th></tr></thead><tbody>
<tr><td align="left"><strong>StoreViewComponent</strong>: custom component type which knows how to work around all the state updates in presence of the <code>store-view</code></td><td align="left"><strong>Component</strong></td></tr>
<tr><td align="left"><strong>StoreViewPrototype</strong>: To make a store view/store view component behave. It's like a merge of <code>FactoryPrototype</code> and <code>ComponentUpdate</code>.</td><td align="left"><strong>FactoryPrototype</strong> + <strong>ComponentUpdate</strong></td></tr>
<tr><td align="left"><strong>StoreViewInnerComponent</strong>: Extra trait extending <code>relm4::Components</code> required by the <code>StoreViewComponent</code>. It allows to send messages to the components in case store was updated.</td><td align="left">N/A</td></tr>
<tr><td align="left"><strong>StoreViewContainerWidget</strong>: Extra trait extending <code>relm4::Widgets</code> required by the <code>StoreViewComponent</code>. It returns the reference to the widget to which factory will add the widgets.</td><td align="left">relm4 doesn't need it. Factory implementation can work it out in all cases</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-architecture"><a class="header" href="#application-architecture">Application architecture</a></h1>
<p>When you write your application in <code>relm4</code> you use classic MVC pattern. <code>relm4-store</code> introduces some &quot;proxies&quot; into the picture.</p>
<p>In <code>relm4</code> terms it looks like this</p>
<p><img src="./assets/mvc.png" alt="relm4 MVC" /></p>
<p>View sends events to component in reaction to user input and component updates the model witch in turn modifies view. <code>relm4::Model</code> combines two roles housekeeping of data in the app and controller of app and view. This two roles are not mixed up thanks to Rust language itself. <code>relm4::ComponentUpdate</code> interface implementation is the controller part and structure implementing <code>relm4::Model</code> is doing the application model part.</p>
<p>When you use this library then this changes into</p>
<p><img src="./assets/mvc-store.png" alt="relm4-store MVC" /></p>
<h2 id="how-does-it-fit-into-my-relm4-application"><a class="header" href="#how-does-it-fit-into-my-relm4-application">How does it fit into my relm4 application</a></h2>
<p><code>relm4-store</code> tries it's best to be an extension to <code>relm4::Model</code> part of an application.</p>
<h3 id="data-store"><a class="header" href="#data-store">Data store</a></h3>
<p>Store is part of the relm4's model. Inside of the store you would keep data which should be persisted. For example</p>
<blockquote>
<p>You are developing a drawing application. In it user can place shapes and draw lines between shapes. When user adds a shape to the drawing area you append it to the list of shapes. If user draws an arrow you append it to the list of arrows. At any point of time user can select one of the elements on the diagram be it arrow or a shape and change it's color.</p>
<p>Using relm4-store you would create two stores, one for shapes and one for arrows. Whenever user draws one of the shapes you would add them to appropriate store. Selection of the diagram element would be kept directly in <code>relm4::Model</code>. State of the color changing window (wherever it's open or not) would also be directly in the <code>relm4::Model</code>. The color change action would on the other hand be sent to one of the stores to handle the update event of one of the records.</p>
<p>Saving a file now would require to read the content of the both stores and writing it down to the file.</p>
</blockquote>
<h3 id="store-view"><a class="header" href="#store-view">Store view</a></h3>
<p>Store view is also part of the relm4's model. It represents current state of the user interface. In case of drawing application example</p>
<blockquote>
<p>You are developing a drawing application. In it user can place shapes and draw lines between shapes. When user adds a shape to the drawing area you append it to the list of shapes. If user draws an arrow you append it to the list of arrows. At any point of time user can select one of the elements on the diagram be it arrow or a shape and change it's color.</p>
<p>Using relm4-store you would create two views (one for each store) for every drawing area showing the diagram</p>
<ul>
<li>Drawing area - 2 store views</li>
<li>Minimap - 2 store views</li>
<li>Split view - 2 store views</li>
<li>...</li>
</ul>
<p>You would use a store view to tell you which shapes to draw. So if you add new shape or an arrow then only affected part of the ui would be updated.</p>
</blockquote>
<h3 id="database-analogy"><a class="header" href="#database-analogy">Database analogy</a></h3>
<p>Other way of thinking about store is to look at it as database table. The store view in such a case is result of the <code>SELECT</code> statement on the store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>In the <code>relm4-store-examples/examples</code> you can find code for examples shown here. If it's the final code for the example it's placed in the folder ending with a number. For simple todo application it can be for example <code>todo_2</code> for the final version from chapter 2. If it's some kind of variation about the code for the application it's suffixed with extra description. For example <code>todo_2_single_scroll</code> shows custom scrollbar being used to navigate a long list.</p>
<h2 id="chapter-summary"><a class="header" href="#chapter-summary">Chapter summary</a></h2>
<ul>
<li><a href="examples/./01-todo/index.html"><strong>Chapter 1</strong></a> Really simple todo application which can show up to 10 tasks.</li>
<li><a href="examples/./02-todo/index.html"><strong>Chapter 2</strong></a> Really simple todo application (from chapter 1) extended to use pagination. This allows to remove a limitation of <code>10 tasks</code> to be seen.</li>
<li><a href="examples/./03-todo/README.html"><strong>Chapter 3</strong></a> We will add sorting into the todo application from chapter 2.</li>
</ul>
<hr />
<p>Things with undecided order</p>
<ul>
<li><a href="examples/./03-todo/README.html"><strong>Data window behavior</strong></a> StoreViews behavior. How to make view behave in the presence of the new data. Really simple todo application from chapter 2 extended to showcase different possibilities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>All examples in this book are using this dependencies in <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
reexport = { package = &quot;relm4-store-reexport&quot;, version=&quot;0.1.0-beta.2&quot; }
record = { package = &quot;relm4-store-record&quot;, version = &quot;0.1.0-beta.2&quot; }
store = { package = &quot;relm4-store&quot;, version = &quot;0.1.0-beta.2&quot; }
store-view = { package = &quot;relm4-store-view-implementation&quot;, version = &quot;0.1.0-beta.2&quot;}
backend_inmemory = { package = &quot;relm4-store-backend-inmemory&quot;, version = &quot;0.1.0-beta.2&quot; }
components = { package = &quot;relm4-store-components&quot;, version = &quot;0.1.0-beta.2&quot; }
log4rs = &quot;1.0.0&quot;
</code></pre>
<h3 id="directly-from-github"><a class="header" href="#directly-from-github">Directly from github</a></h3>
<pre><code class="language-toml">[dependencies]
reexport = { git = &quot;https://github.com/mskorkowski/relm4-store&quot;, branch = &quot;main&quot;, package = &quot;relm4-store-reexport&quot; }
record = { git = &quot;https://github.com/mskorkowski/relm4-store&quot;, branch = &quot;main&quot;, package = &quot;relm4-store-record&quot; }
store = { git = &quot;https://github.com/mskorkowski/relm4-store&quot;, branch = &quot;main&quot;, package = &quot;relm4-store&quot; }
store-view = { git = &quot;https://github.com/mskorkowski/relm4-store&quot;, branch = &quot;main&quot;, package = &quot;relm4-store-view-implementation&quot;}
backend_inmemory = { git = &quot;https://github.com/mskorkowski/relm4-store&quot;, branch = &quot;main&quot;, package = &quot;relm4-store-backend-inmemory&quot; }
components = { git = &quot;https://github.com/mskorkowski/relm4-store&quot;, branch = &quot;main&quot;, package = &quot;relm4-store-components&quot; }
log4rs = &quot;1.0.0&quot;
</code></pre>
<ol>
<li>API is rather stable but somebody might have an idea how to make it better/easier and things will change without a notice</li>
<li>Running against anything other then <code>main</code> branch is considered mental. We try our best to keep <code>main</code> working and tested (as far as tests are created). If you find there is some feature marked as <code>done</code> on the <a href="examples/../02-goals.html">goals list</a> and there are issues with it please fill the bug.</li>
<li>If feature isn't marked as complete you can also fill the bug report. This might (or might not) get it prioritized. Definitely you will get the answer as soon as I spot it. You are welcome to contribute by the way.</li>
</ol>
<h2 id="log4rs"><a class="header" href="#log4rs">log4rs</a></h2>
<p>Internally <code>relm4_store</code> is using <code>log</code> crate. <code>reexport::log</code> reexports it. In examples we are setting up <code>log4rs</code> to manage the log output. In examples folder you can find any required configuration file in the <code>etc</code> directory. For example <code>log4rs.yaml</code> for <code>todo_1</code> is in <code>relm4-store-examples/examples/todo1/etc/log4rs.yaml</code>. At the end of any chapter all configuration filles will be posted.</p>
<pre><code class="language-yaml">refresh_rate: 30 seconds

appenders:
  stdout:
    kind: console
    encoder:
      pattern: &quot;{h({l})} [ {f}:{L} ] {m}{n}&quot;

root:
  level: warn
  appenders:
    - stdout

loggers:
  backend_inmemory::backend:
    level: info
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-todo-application"><a class="header" href="#simple-todo-application">Simple todo application</a></h1>
<p>In this section we will introduce basics of stores and implement example <code>todo_1</code> from examples folder.</p>
<p><code>todo_1</code> is simple todo application. Spec goes like this:</p>
<ul>
<li>You start with empty list of tasks</li>
<li>You can add new tasks</li>
<li>You can mark task as complete</li>
<li>You can remove tasks4</li>
</ul>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>This chapter is an introduction to the Store concept. You will find here how to define simple store and how you can use it in relm4 application.</p>
<p>The application is too simple to be good showcase for the capabilities of the Store. In later chapters we will write a more complex applications which would show real benefits of Stores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>We are writing simple todo list. So we need to talk about tasks!</p>
<p>Task will have the description and status wherever it's completed or not.</p>
<p>So let's start with it. Create a file <code>model/task.rs</code> and write there</p>
<pre><code class="language-rust noplaypen">use std::fmt::{self, Debug, Display, Formatter};

use record::{Id, Record, DefaultIdAllocator, TemporaryIdAllocator};

#[derive(Clone, Debug)]
pub struct Task {
    id: Id&lt;Task&gt;,
    pub description: String,
    pub completed: bool,
}

impl Task {
    pub fn new(description: String, completed: bool) -&gt; Self {
        Self{
            id: Id::new(),
            description,
            completed,
        }
    }
}

impl Record for Task {
    type Allocator = DefaultIdAllocator;
    fn get_id(&amp;self) -&gt; Id&lt;Task&gt; {
        self.id
    }

    fn set_permanent_id(
        &amp;mut self, 
        value: &lt;Self::Allocator as TemporaryIdAllocator&gt;::Type
    ) -&gt; Result&lt;(), record::IdentityError&gt; {
        self.id = Id::from(value);
        Ok( () )
    }
}
</code></pre>
<p>This is minimal implementation for record. It consist of</p>
<ol>
<li>Definition of <code>Task</code> structure</li>
<li>Implementation for <code>Task</code> which provides method <code>new</code>.</li>
<li>Implementation of <code>record::Record</code> (<code>relm4_store_record::Record</code>)</li>
</ol>
<h2 id="task-structure"><a class="header" href="#task-structure"><code>Task</code> structure</a></h2>
<p>First we defined structure <code>Task</code>. It has a three fields. First is an <code>id</code>. This filed is used to identify the record in the store. This <code>id</code> must be stable during whole application execution. Later we have a description. It will contain the description of the task. At the end there is boolean flag which will let us know if the task has been completed or not.</p>
<p>Task derives two traits <code>Clone</code> and <code>Debug</code>. <code>Debug</code> is obvious. <code>Clone</code> is consequence of what <code>Record</code> is. Since you can save a record in the database it's equivalent of <code>Clone</code>. What's more without <code>Clone</code> it would be hard to reason about multiple views showing same record. It also allows to escape the lifetime boundary issues. Store is a collection of records. So whatever you will place there should have <code>'static</code> lifetime. Now let's think about keeping references to the records with <code>'static</code> lifetime which are being removed while application is being run. It sounds like going against what `'static' is. It isn't but requires so many lifetime annotations and makes code way overcomplicated.</p>
<h2 id="implementation-of-task"><a class="header" href="#implementation-of-task">Implementation of <code>Task</code></a></h2>
<p>As good practice I strongly suggest</p>
<ol>
<li>That you implement <code>new</code> for your business model structures. <code>new</code> should return really &quot;new&quot; instance so identifier should be set to <code>Id::New</code>.</li>
<li>In case you need to recreate an instance I would suggest using <code>from</code> method.</li>
</ol>
<p>It's related to the expected behavior of implementations of <code>Record</code>. Two instances of the business model are expected to represent the same value if their identifier is equal and not when internals are in the same state. You might think about <code>Record</code> as photograph of the business state at some point of time. You can have multiple photos of the <code>Record</code> but it's up to you to tell which is newer and which is older.</p>
<p>We can end our business modelling session now, except I like to add some pretty printing abilities to my business model classes. It's alway useful to be able to println them to see what happens.</p>
<pre><code class="language-rust noplaypen">impl Display for Task {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let completed = if self.completed {'x'} else {' '};
        f.write_str(&amp;format!(&quot;[{}] {}&quot;, completed, self.description))
    }
}
</code></pre>
<h2 id="implementation-of-recordrecord-for-task"><a class="header" href="#implementation-of-recordrecord-for-task">Implementation of <code>record::Record</code> for <code>Task</code></a></h2>
<p>Here is how we implemented the Record structure.</p>
<pre><code class="language-rust noplaypen">impl Record for Task {
    type Allocator = DefaultIdAllocator;
    fn get_id(&amp;self) -&gt; Id&lt;Task&gt; {
        self.id
    }

    fn set_permanent_id(
        &amp;mut self, 
        value: &lt;Self::Allocator as TemporaryIdAllocator&gt;::Type
    ) -&gt; Result&lt;(), record::IdentityError&gt; {
        self.id = Id::from(value);
        Ok( () )
    }
}
</code></pre>
<p>There are two methods and one type defined there. Method <code>get_id</code> is rather self explanatory. It returns current value of record identifier which we discussed in <code>Task structure</code> section. Method <code>set_permanent_id</code> overrides current value of id with new stable final version of identifier.</p>
<p>It's responsibility of the data store and backend to track down this information and propagate it. Why would you need something like that? The scenario I was solving for myself is &quot;how application should behave in presence of slow backend&quot;.</p>
<p>Without this feature when I commit a record to the slow backend I need to wait for the backend to respond with information about saving the record and I under which this record was saved before I can safely show it to user. Other method would be to track down which records are committed and which not. This might involve things like remembering that record without id at the 5th position of some list is the one which should be updated when 2nd http request is successful. It sound painful. Implementing it definitely is. Even if we assume you can do it bug free. Write it down 3 times for slightly different scenarios. So how did we solve it then? By making it data definition problem.</p>
<ol>
<li>Id must be unique. Two instances of the <code>Task</code> are considered to represent same record at maybe different point of time if their id is equal</li>
<li>In scope of the application, you must be able to return new unique id's during whole application lifetime. This allows you to provide temporary id's which are unique in currently running application. It doesn't matter if two running applications provide same unique id because when records from other application will be visible to this application only after being committed to the backend (for example database) which in turn would make them contain permanent id instead of temporary one. So this application will never see temporary id of other application</li>
<li>You are not allowed to keep copy of records with non permanent id. In most cases it's not an issue. Since after you create a record anc commit it to the database you don't really have a reason to keep copy of it. If for some reason you must keep the record around you are responsible for tracking this information</li>
<li>Only backend is allowed to call <code>set_permanent_id</code></li>
</ol>
<p>I'm going to elaborate little bit more about 4th point. To make it clear how bad it's to call it outside of the backend.</p>
<p>Let's assume you have a record like that</p>
<pre><code class="language-rust noplaypen">struct User {
    id: Id&lt;User&gt;,
    pub name: String,
}

impl Record for User {
    type Allocator = UserIdAllocator;

    fn get_id(&amp;self) -&gt; Id&lt;Task&gt; {
        self.id
    }

    fn set_permanent_id(
        &amp;mut self, 
        value: &lt;Self::Allocator as TemporaryIdAllocator&gt;::Type
    ) -&gt; Result&lt;(), record::IdentityError&gt; {
        self.id = Id::from(value);
        Ok( () )
    }
}
</code></pre>
<p>Somewhere in the code you've created a code like this:</p>
<pre><code class="language-rust noplaypen">fn new_user_from(mut u: User) -&gt; User {
    let id = UserIdAllocator::getId();
    u.set_permanent_id()
}
</code></pre>
<p>You compile and test your application. Everything works.</p>
<p>Now few request later you change the user definition:</p>
<pre><code class="language-rust noplaypen">struct User {
    id: Id&lt;User&gt;,
    pub name: String,
    // must be unique across all users
    pub unique_email: String,
}
</code></pre>
<p>Your code still compiles. But now anytime you invoke the <code>new_user_from</code> you produce a value which breaks your business model a little bit. If you are not really careful with your tests this error might live in your code base for very long time.</p>
<p>I've seen bugs similar to this one living in the production systems for years. Fixing them afterwards is at least problematic and more often impossible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store"><a class="header" href="#store">Store</a></h1>
<p>We need to keep todo data somewhere. So let's crate a first store in file <code>store/tasks.rs</code>.</p>
<pre><code class="language-rust noplaypen">use backend_inmemory::InMemoryBackend;
use backend_inmemory::InMemoryBackendConfiguration;
use store::Store;

use crate::model::Task;

pub type Tasks = Store&lt;InMemoryBackend&lt;TasksBuilder&gt;&gt;;

pub struct TasksBuilder {}

impl TasksBuilder{
    pub fn build() -&gt; Tasks {
        Tasks::new(
            InMemoryBackend::new()
        )
    }
}

impl InMemoryBackendConfiguration for TasksBuilder
{
    type Record = Task;

    fn initial_data() -&gt; Vec&lt;Self::Record&gt; {
        Vec::new()
    }
}
</code></pre>
<p>That's it folks. Done. We've just implemented first store.</p>
<p>Ok, let's see what happens there</p>
<pre><code class="language-rust noplaypen">use backend_inmemory::InMemoryBackend;
</code></pre>
<p>In this line we import <code>InMemoryBackend</code>. It's a Store backend which keeps all data in the memory. The easiest one to use but you will loose all the data on application restart.</p>
<pre><code class="language-rust noplaypen">pub type Tasks = Store&lt;InMemoryBackend&lt;TasksBuilder&gt;&gt;;
</code></pre>
<p>Here we define the convenient label for our store type. If we decide to change a backend, that's a place where we should do the update. You should never use backend types directly outside your store implementation. This will reduce amount of changes you must do in the code if you switch them. Maybe not often but changing a backend is sometimes necessity and being tight to it is bad. All patterns we will show in this book will try to minimize exposure the backend to the rest of your code.</p>
<pre><code class="language-rust noplaypen">pub struct TasksBuilder {}

impl TasksBuilder{
    pub fn build() -&gt; Tasks {
        Tasks::new(
            InMemoryBackend::new()
        )
    }
}

impl InMemoryBackendConfiguration for TasksBuilder
{
    type Record = Task;

    fn initial_data() -&gt; Vec&lt;Self::Record&gt; {
        Vec::new()
    }
}
</code></pre>
<p>In here we define the builder structure which will provide us the new instance of the store with tasks and provides configuration of your backend. In most of the cases having one structure for both tasks is totally fine. In case you need some fancier builder you will probably split the configuration and keep it private in the module and have builder do just building.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view---task-list"><a class="header" href="#view---task-list">View - Task list</a></h1>
<p>Our view will have a two parts. If you know <code>relm4</code> you will see lots of similarities here.</p>
<ol>
<li>Task widget and tasks list</li>
<li>Main window</li>
</ol>
<p>I've decided to split the view this way so each part of implementation is easier to understand.</p>
<h2 id="list-of-tasks"><a class="header" href="#list-of-tasks">List of tasks</a></h2>
<p>All snippets in this section should go to <code>view/task_list.rs</code></p>
<h3 id="list-of-imports"><a class="header" href="#list-of-imports">List of imports</a></h3>
<p>There will be a lots of them here. I'm providing them here so they won't obstruct the examples later. We will cover all important parts later in this chapter.</p>
<pre><code class="language-rust noplaypen">use reexport::gtk;
use reexport::relm4;
use reexport::relm4_macros;
use store_view::View;

use gtk::Box;
use gtk::CheckButton;
use gtk::Label;
use gtk::Orientation;
use gtk::prelude::BoxExt;
use gtk::prelude::CheckButtonExt;
use gtk::prelude::EntryExt;
use gtk::prelude::EntryBufferExtManual;
use gtk::prelude::OrientableExt;
use gtk::prelude::WidgetExt;

use relm4::Model as ViewModel;
use relm4::send;
use relm4::Sender;
use relm4::Widgets;
use relm4::WidgetPlus;
use relm4_macros::widget;

use record::Id;
use record::Record;
use store::StoreViewPrototype;
use store::FactoryContainerWidgets;
use store::DataStore;
use store::Position;
use store::window::PositionTrackingWindow;

use crate::model::Task;
use crate::store::Tasks;
</code></pre>
<h3 id="task-widget-and-task-list"><a class="header" href="#task-widget-and-task-list">Task widget and task list</a></h3>
<p>Firstly we need to define structures which will keep our widgets around.</p>
<pre><code class="language-rust noplaypen">type StoreMsg = store::StoreMsg&lt;Task&gt;;

pub enum TaskMsg {
    Toggle{
        complete: bool,
        id: Id&lt;Task&gt;,
    },
    New,
}

#[derive(Debug)]
#[allow(dead_code)]
pub struct TaskWidgets {
    checkbox: CheckButton,
    label: Label,
    root: Box,
}

pub trait TasksListConfiguration {
    type ParentViewModel: ViewModel;
    fn get_tasks(parent_view_model: &amp;Self::ParentViewModel) -&gt; Tasks;
}

pub struct TasksListViewModel&lt;Config: TasksListConfiguration + 'static&gt; {
    tasks: Tasks,
    store_view: View&lt;Self&gt;,
    new_task_description: gtk::EntryBuffer,
}
</code></pre>
<p>Let's discuss it one by one.</p>
<p>The first thing is definition of the <code>StoreMsg</code> type. In your code you will interact with store. Main goal of this type alias is to reduce amount of typing. All stores and store views are using <code>store::StoreMsg</code> to communicate between each other and using it is only way to affect state of the data store. <code>store::StoreMsg</code> is parametrized by the type of Record so you won't be able to send a message of the wrong type to the store.</p>
<p>The second one is <code>TaskWidgets</code>. Exactly same structure you would be defining if you would use <code>relm4</code> factories. Checkbox to mark task as complete, label to keep task description and a box (root) to keep it together.</p>
<p>The third one is <code>TasksListConfiguration</code>. It's part of the component pattern to allow more then one instance of the component to be shown at the same time. It contains a method <code>get_tasks</code> which will return instance of the <code>store::Store</code>.</p>
<p>Finally <code>TasksListViewModel</code>. First really interesting things happens here. First attribute is <code>tasks</code> it's the data store which keeps all the data. We will need it to notify the store about status changes of the tasks. Second attribute is store_view. It will provide view into your store.</p>
<h3 id="relm4model-implementation-for-taskslistviewmodel"><a class="header" href="#relm4model-implementation-for-taskslistviewmodel"><code>relm4::Model</code> implementation for <code>TasksListViewModel</code></a></h3>
<p>This part is obvious</p>
<pre><code class="language-rust noplaypen">impl&lt;Config: TasksListConfiguration&gt; ViewModel for TasksListViewModel&lt;Config&gt; {
    type Msg = TaskMsg;
    type Widgets = TasksListViewWidgets;
    type Components = ();
}
</code></pre>
<h3 id="storeviewprototype"><a class="header" href="#storeviewprototype"><code>StoreViewPrototype</code></a></h3>
<p>In here we will implement <code>store::StoreViewPrototype</code> to provide a view for items in the store. You would use <code>StoreViewPrototype</code> trait in all the places where using pure <code>relm4</code> you would use <code>relm4::factory::FactoryPrototype</code>.</p>
<p>Differences between the <code>relm4::factory::FactoryPrototype</code> and <code>store::StoreViewPrototype</code></p>
<table><thead><tr><th align="left">What</th><th align="left">FactoryPrototype</th><th align="left">StoreViewPrototype</th></tr></thead><tbody>
<tr><td align="left"><strong>Target of implementation</strong></td><td align="left">You implement it for the ViewModel.</td><td align="left">You implement it for whatever you like. This makes this interface behave more like configuration.</td></tr>
<tr><td align="left"><strong>Data container</strong></td><td align="left"><code>type Factory</code> which points to data container in the ViewModel</td><td align="left"><code>type Store</code> which points to data container type. There is no requirement of it being inside of <code>ViewModel</code>.</td></tr>
<tr><td align="left"><strong>Data visibility</strong></td><td align="left">All data in the factory are visible.</td><td align="left">Only part of data in the Store is visible. <code>type Window</code> defines how the view window behaves (more in chapter 2 and 3).</td></tr>
<tr><td align="left">Method signature</td><td align="left">Since you implemented the factory for the ViewModel, it takes <code>self</code> as an argument. You create a widgets to display <code>self</code>. Second is key under which factory is going to find it. Key is unstable and managed by the factory.</td><td align="left">It's not bound to <code>self</code>. First is record for which widgets should be created. Second is position in the store. Position in the dataset at the time of widget generation. There is no guarantee to get the same widget in the future when asking store for record at the given position. Record is required to hold stable id by implementing <code>model::Identifialble</code>.</td></tr>
</tbody></table>
<p>Let's create a file <code>view/task.rs</code></p>
<pre><code class="language-rust noplaypen">impl&lt;Config: TasksListConfiguration&gt; StoreViewPrototype 
    for TasksListViewModel&lt;Config&gt; 
{
    type Store = Tasks;
    type StoreView = View&lt;Self&gt;;
    type RecordWidgets = TaskWidgets;
    type Root = gtk::Box;
    type View = gtk::Box;
    type Window = PositionTrackingWindow;
    type ViewModel = Self;
    type ParentViewModel = Config::ParentViewModel;

    fn init_store_view(
        store: Self::Store, 
        size: store::StoreSize, 
        redraw_sender: Sender&lt;store::redraw_messages::RedrawMessages&gt;
    ) -&gt; Self::StoreView {
        View::new(store, size, redraw_sender)
    }

    fn init_view(
        record: &amp;Task,
        _position: Position,
        sender: Sender&lt;TaskMsg&gt;,
    ) -&gt; Self::RecordWidgets {
        let root = Box::builder()
            .orientation(Orientation::Horizontal)
            .build();

        let checkbox = CheckButton::builder()
            .margin_top(12)
            .margin_start(12)
            .margin_end(12)
            .margin_bottom(12)
            .active(record.completed)
            .build();

        {
            let sender = sender.clone();
            let id = record.get_id();

            checkbox.connect_toggled(move |btn| {
                send!(sender, TaskMsg::Toggle{
                    id,
                    complete: btn.is_active()
                });
            });
        }

        let label = Label::builder()
            .margin_top(12)
            .margin_start(12)
            .margin_end(12)
            .margin_bottom(12)
            .label(&amp;record.description)
            .build();

        root.append(&amp;checkbox);
        root.append(&amp;label);

        TaskWidgets {
            checkbox,
            label,
            root,
        }
    }

    /// Function called when record is modified.
    fn view(
        record: Task,
        _position: Position,
        widgets: &amp;Self::RecordWidgets,
    ) {
        widgets.checkbox.set_active(record.completed);

        let attrs = widgets.label.attributes().unwrap_or_default();
        attrs.change(gtk::pango::AttrInt::new_strikethrough(record.completed));
        widgets.label.set_attributes(Some(&amp;attrs));
    }

    fn position(
        _model: Task, 
        _position: Position,
    ) {}

    /// Get the outermost widget from the widgets.
    fn root_widget(widgets: &amp;Self::RecordWidgets) -&gt; &amp;Self::Root {
        &amp;widgets.root
    }

    fn update(
        view_model: &amp;mut Self::ViewModel, 
        msg: &lt;Self as ViewModel&gt;::Msg, 
        _sender: Sender&lt;&lt;Self as ViewModel&gt;::Msg&gt;
    ) {
        match msg {
            TaskMsg::New =&gt; {
                let description = view_model.new_task_description.text();
                let task = Task::new(description, false);
                view_model.new_task_description.set_text(&quot;&quot;);
                view_model.tasks.send(StoreMsg::Commit(task));
            },
            TaskMsg::Toggle{ complete, id } =&gt; {
                let tasks = &amp;view_model.tasks;
                if let Some(record) = tasks.get(&amp;id) {
                    let mut updated = record.clone();
                    updated.completed = complete;
                    tasks.send(StoreMsg::Commit(updated));
                }
            },
        }
    }

    fn init_view_model(
        parent_view_model: &amp;Self::ParentViewModel, 
        store_view: &amp;Self::StoreView
    ) -&gt; Self {
        TasksListViewModel{
            tasks: Config::get_tasks(parent_view_model),
            new_task_description: gtk::EntryBuffer::new(None),
            store_view: store_view.clone(),
        }
    }
}
</code></pre>
<p>Let's look at the first part of <code>StoreViewPrototype</code> implementation</p>
<pre><code class="language-rust noplaypen">    type Store = Tasks;
    type StoreView = View&lt;Self&gt;;
    type RecordWidgets = TaskWidgets;
    type Root = gtk::Box;
    type View = gtk::Box;
    type Window = PositionTrackingWindow;
    type ViewModel = Self;
    type ParentViewModel = Config::ParentViewModel;
</code></pre>
<table><thead><tr><th align="left">type name</th><th align="left">value</th><th align="left">meaning</th></tr></thead><tbody>
<tr><td align="left">Store</td><td align="left"><code>Tasks</code></td><td align="left">This type provides information about which store type will be used. This itself also provides information abut the model which (<code>DataStoreBase::Model</code>) which is used by the related store and as the consequence this view. In relm4's <code>FactoryPrototype</code> you would provide factory type where your data would be stored.</td></tr>
<tr><td align="left">StoreView</td><td align="left"><code>View&lt;TasksListViewModel&gt;</code></td><td align="left">This type provides information about which store view type will be used. In <code>relm4</code> this would be part of <code>FactoryPrototype</code>. It's responsible for providing view into the store</td></tr>
<tr><td align="left">RecordWidgets</td><td align="left"><code>TaskWidgets</code></td><td align="left">The same as in relm4's <code>FactoryPrototype::Widgets</code>. Type of structure holding all widgets.</td></tr>
<tr><td align="left">Root</td><td align="left"><code>gtk::Box</code></td><td align="left">Type of widget which is a root for all widgets kept in the <code>RecordWidgets</code>. Same as in <code>FactoryPrototype::Root</code>.</td></tr>
<tr><td align="left">View</td><td align="left"><code>gtk::Box</code></td><td align="left">Type of widgets which will keep the list of widgets. (The widget to which factory should add widgets to). Same as in <code>FactoryPrototype::View</code>. There must exist implementations of <code>relm4::factory::FactoryView</code> and <code>relm4::factory::FactoryListView</code> for <code>View</code>.</td></tr>
<tr><td align="left">Window</td><td align="left"><code>PositionTrackingWindow</code></td><td align="left">Describes how the view window will behave in case of new data. For now use <code>PositionTrackingWindow</code> with annotation that if you don't know what to use, this one is probably the one.</td></tr>
<tr><td align="left">ViewModel</td><td align="left"><code>TasksListViewModel</code></td><td align="left">Provides information about type of view model used by implementation of the <code>StoreViewPrototype</code></td></tr>
<tr><td align="left">ParentViewModel</td><td align="left"><code>Config::ParentViewModel</code></td><td align="left">Provides information about the parent view model. Used during initialization of the view model</td></tr>
</tbody></table>
<h4 id="init_store_view"><a class="header" href="#init_store_view"><code>init_store_view</code></a></h4>
<p>This method is responsible for creating instance of the store view. In here you connect your view with store and make sure your view has all required properties.</p>
<pre><code class="language-rust noplaypen">    fn init_store_view(
        store: Self::Store, 
        size: store::StoreSize, 
        redraw_sender: Sender&lt;store::redraw_messages::RedrawMessages&gt;
    ) -&gt; Self::StoreView {
        View::new(store, size, redraw_sender)
    }
</code></pre>
<h4 id="relm4factoryfactoryprototype"><a class="header" href="#relm4factoryfactoryprototype"><code>relm4::factory::FactoryPrototype</code></a></h4>
<p>Next we implemented <code>init_view</code>, <code>view</code>, <code>position</code> and <code>root_widget</code> methods. All four methods are equivalents of the methods with the same name in <code>FactoryPrototype</code>.</p>
<h4 id="relm4componentupdate"><a class="header" href="#relm4componentupdate"><code>relm4::ComponentUpdate</code></a></h4>
<p>This method is equivalent of <code>update</code> for <code>ComponentUpdate</code>.  <code>init_view_model</code> is <code>init_model</code> from <code>ComponentUpdate</code>.</p>
<h3 id="tasklistviewwidgets"><a class="header" href="#tasklistviewwidgets">TaskListViewWidgets</a></h3>
<p>Now we can create our widgets for showing whole list</p>
<pre><code class="language-rust noplaypen">#[widget(visibility=pub, relm4=reexport::relm4)]
impl&lt;Config: TasksListConfiguration&gt; 
    Widgets&lt;TasksListViewModel&lt;Config&gt;, Config::ParentViewModel&gt; 
    for TasksListViewWidgets 
{
    view!{
        root = gtk::Box {
            set_margin_all: 12,
            set_orientation: gtk::Orientation::Vertical,
            append = &amp;gtk::Entry::with_buffer(&amp;model.new_task_description) {
                connect_activate(sender) =&gt; move |_| { 
                    send!(sender, TaskMsg::New); 
                } 
            },
            append = &amp;gtk::ScrolledWindow {
                set_hexpand: true,
                set_vexpand: true,
                set_child: container = Some(&amp;gtk::Box) {
                    set_orientation: gtk::Orientation::Vertical,
                    factory!(model.store_view)
                }
            }
        }
    }
}
</code></pre>
<p>There are only two interesting things here. First <code>StoreView</code> is kind of relm4 factory.</p>
<pre><code class="language-rust noplaypen">                    factory!(model.store_view)
</code></pre>
<p>Second is</p>
<pre><code class="language-rust noplaypen">                set_child: container = Some(&amp;gtk::Box) {
                    set_orientation: gtk::Orientation::Vertical,
                    factory!(model.store_view)
                }
</code></pre>
<p>In here we've named container handling our list of tasks. It's important so the component knows which element to provide to relm4's <code>Factory::init_view</code> method.</p>
<p>Rest is classic relm4.</p>
<h4 id="factorycontainerwidgets"><a class="header" href="#factorycontainerwidgets">FactoryContainerWidgets</a></h4>
<p>Now we need to implement extra trait <code>store::FactoryContainerWidgets</code></p>
<pre><code class="language-rust noplaypen">impl&lt;Config: TasksListConfiguration&gt; 
    FactoryContainerWidgets&lt;TasksListViewModel&lt;Config&gt;&gt; 
    for TasksListViewWidgets 
{
    fn container_widget(&amp;self) 
        -&gt; &amp;&lt;TasksListViewModel&lt;Config&gt; as StoreViewPrototype&gt;::View 
    {
        &amp;self.container
    }
}
</code></pre>
<p>In here we return reference to the widget used to keep whole list of our tasks</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view---main-window"><a class="header" href="#view---main-window">View - Main window</a></h1>
<p>view/main_window.rs</p>
<pre><code class="language-rust noplaypen">use reexport::{gtk, relm4, relm4_macros};
use gtk::prelude::GtkWindowExt;
use relm4::{AppUpdate, Components, Model as ViewModel, Sender, Widgets};
use relm4_macros::widget;
use store::{StoreSize, StoreViewComponent};

use crate::{
    store::Tasks,
    view::{ task_list::TasksListConfiguration, task_list::TasksListViewModel}
};

pub enum MainWindowMsg {}

pub struct MainWindowViewModel {
    pub tasks: Tasks
}

impl ViewModel for MainWindowViewModel {
    type Msg = MainWindowMsg;
    type Widgets = MainWindowWidgets;
    type Components = MainWindowComponents;
}

impl AppUpdate for MainWindowViewModel {
    fn update(
        &amp;mut self, 
        _msg: Self::Msg , 
        _components: &amp;Self::Components, 
        _sender: Sender&lt;Self::Msg&gt;
    ) -&gt; bool {
        true
    }
}

pub struct MainWindowComponents {
    tasks_list: StoreViewComponent&lt;TasksListViewModel&lt;Self&gt;&gt;
}

impl Components&lt;MainWindowViewModel&gt; for MainWindowComponents {
    fn init_components(
        parent_model: &amp;MainWindowViewModel,
        _parent_sender: Sender&lt;MainWindowMsg&gt;,
    ) -&gt; Self {
        Self {
            tasks_list: StoreViewComponent::new(
                parent_model,
                parent_model.tasks.clone(),
                StoreSize::Unlimited)
        }
    }

    fn connect_parent(&amp;mut self, _parent_widgets: &amp;MainWindowWidgets) { }
}

impl TasksListConfiguration for MainWindowComponents {
    type ParentViewModel = MainWindowViewModel;

    fn get_tasks(parent_model: &amp;Self::ParentViewModel) -&gt; Tasks {
        parent_model.tasks.clone()
    }
}



#[widget(visibility=pub, relm4=relm4)]
impl Widgets&lt;MainWindowViewModel, ()&gt; for MainWindowWidgets {
    view!{
        root = gtk::ApplicationWindow {
            set_child: Some(components.tasks_list.root_widget()),
            set_default_size: args!(350, 800),
        }
    }
}
</code></pre>
<p>There are few things to take a note.</p>
<p>First <code>MainWindowModel</code> holds tasks store.</p>
<pre><code class="language-rust noplaypen">pub struct MainWindowViewModel {
    pub tasks: Tasks
}
</code></pre>
<p>Second is that instead of <code>RelmComponent</code> we use <code>StoreViewComponent</code>.</p>
<pre><code class="language-rust noplaypen">pub struct MainWindowComponents {
    tasks_list: StoreViewComponent&lt;TasksListViewModel&lt;Self&gt;&gt;
}
</code></pre>
<pre><code class="language-rust noplaypen">    fn init_components(
        parent_model: &amp;MainWindowViewModel,
        _parent_sender: Sender&lt;MainWindowMsg&gt;,
    ) -&gt; Self {
        Self {
            tasks_list: StoreViewComponent::new(
                parent_model,
                parent_model.tasks.clone(),
                StoreSize::Unlimited)
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-it-up"><a class="header" href="#wrapping-it-up">Wrapping it up</a></h1>
<p>main.rs</p>
<pre><code class="language-rust noplaypen">mod model;
mod store;
mod view;

use reexport::log;
use reexport::gtk;
use reexport::relm4;

use std::io::Result;

use relm4::RelmApp;

use crate::store::TasksBuilder;
use crate::view::MainWindowViewModel;

fn main() -&gt; Result&lt;()&gt; {
    log4rs::init_file(
        &quot;relm4-store-examples/examples/todo_1/etc/log4rs.yaml&quot;,
        Default::default()
    ).unwrap();

    log::info!(&quot;&quot;);
    log::info!(&quot;Todo 1 example!&quot;);
    log::info!(&quot;&quot;);

    
    let app_id = &quot;store.relm4.example.todo-1&quot;;
    
    gtk::init().expect(&quot;Couldn't initialize gtk&quot;);
    let application = gtk::Application::builder()
        .application_id(app_id)
        .build();

    let model = MainWindowViewModel{
        tasks: TasksBuilder::build()
    };

    log::info!(&quot;\tCreating relm4 app&quot;);
    let app = RelmApp::with_app(model, application);

    log::info!(&quot;\tStarting app&quot;);
    app.run();

    Ok(())
}
</code></pre>
<p>During creation of main window model, we've created the store with tasks.</p>
<pre><code class="language-rust noplaypen">    let model = MainWindowViewModel{
        tasks: TasksBuilder::build()
    };
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>You've learnt how to create an in memory store</li>
<li>You've learnt how to create a store view and show the data in the store</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>In <code>todo_1</code> there is only one configuration file.</p>
<h2 id="etclog4rsyaml"><a class="header" href="#etclog4rsyaml"><code>etc/log4rs.yaml</code></a></h2>
<pre><code class="language-yaml">refresh_rate: 30 seconds

appenders:
  stdout:
    kind: console
    encoder:
      pattern: &quot;{h({l})} [ {f}:{L} ] {m}{n}&quot;

root:
  level: warn
  appenders:
    - stdout

loggers:
  backend_inmemory::backend:
    level: info
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-todo-application-with-pagination"><a class="header" href="#simple-todo-application-with-pagination">Simple todo application with pagination</a></h1>
<p>In first chapter we've implemented a simple todo application. It has one limitation, if our task list would grow big enough then view would be slow.</p>
<ul>
<li>We will generate 20000 tasks</li>
<li>We will allow max 50 tasks at any given time</li>
<li>We will implement pagination so we can navigate to see all of the data in the store</li>
</ul>
<p>Whole source code can be found as example <code>todo_2</code></p>
<h2 id="goals-1"><a class="header" href="#goals-1">Goals</a></h2>
<ul>
<li>Describe StoreView in details</li>
<li>Implement pagination for the list of tasks</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-tasks"><a class="header" href="#generating-tasks">Generating tasks</a></h1>
<p>Now we will generate 20015 tasks to be kept in our store. Why 20015?</p>
<ul>
<li>Because it will leave last page just partially filled. We will use page size of 50 tasks.</li>
<li>Because it's value big enough to be meaningful</li>
</ul>
<p>In <code>store/tasks.rs</code> we modify the <code>TaskBuilder</code>.</p>
<pre><code class="language-rust noplaypen">impl InMemoryBackendConfiguration for TasksBuilder
{
    type Record = Task;

    fn initial_data() -&gt; Vec&lt;Self::Record&gt; {
        let mut initial_tasks = Vec::new();

        for i in 0..20015 {
            initial_tasks.push(
                Task::new(format!(&quot;Sample task {}&quot;, i), false)
            );
        }

        initial_tasks
    }
}
</code></pre>
<p>If you start an application it will take a quite bit of the time before interface will even show up. Now if your application would need to show lists like that, it would feel unusable. So now we need to do something about the view.</p>
<p>Code after this step can be found in example <code>todo_2_generating_tasks</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-store-view"><a class="header" href="#updating-store-view">Updating store view</a></h1>
<h2 id="preface"><a class="header" href="#preface">Preface</a></h2>
<p>Now our application needs to deal with quite a few records to display. In the real world there are three basic strategies to deal with big number of records and make ui reasonable to users.</p>
<ol>
<li>Pagination</li>
<li>Filtering</li>
<li>Grouping</li>
</ol>
<h3 id="pagination"><a class="header" href="#pagination">Pagination</a></h3>
<p>When you use pagination you reduce visible amount of data to value which are known to the store view. This way you we don't need to render all of the widgets from which most of them are not visible. Proper size of page, makes it human understandable and makes the application fast. You should use pagination when the amount of data in the store is much more then you can show on the screen (in most of the cases it means always). In this chapter we will focus on pagination.</p>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<p>Filtering on the other hand reduces amount of data which store can provide to the store view. For humans it gives an option to see only elements in the store which share some property. How to add filtering will be discussed in chapter 4. You should use filtering whenever your store may contain more the 10 elements (again almost always). This allows user to find the data he's interested into.</p>
<h3 id="grouping"><a class="header" href="#grouping">Grouping</a></h3>
<p>Grouping provides better conceptual view for data in the store by splitting them into smaller subsets with common property. You might use it when there are natural groups defined.</p>
<p>For example you have a store of files in transactions. Single file belongs to one transaction but transaction can have multiple files. This gives natural grouping of files by transactions to which they belong to.</p>
<p>Other example could be accounting system. Let's assume you have a store with invoices. Now you might group them by the accounting month to which they belong to.</p>
<h2 id="lets-implement-pagination"><a class="header" href="#lets-implement-pagination">Let's implement pagination</a></h2>
<p>In the <code>view/main_window.rs</code> we change <code>StoreSize::Unlimited</code> into <code>StoreSize::Items(50)</code></p>
<pre><code class="language-rust noplaypen">impl Components&lt;MainWindowViewModel&gt; for MainWindowComponents {
    fn init_components(
        parent_model: &amp;MainWindowViewModel,
        _parent_sender: Sender&lt;MainWindowMsg&gt;,
    ) -&gt; Self {
        Self {
            tasks_list: StoreViewComponent::new(
                parent_model,
                parent_model.tasks.clone(),
                StoreSize::Items(50)
            ),
        }
    }

    fn connect_parent(&amp;mut self, _parent_widgets: &amp;MainWindowWidgets) { }
}
</code></pre>
<p>If you start an application now you will find that</p>
<ul>
<li>only first 50 records were shown and there is no way for you to go past that</li>
<li>new tasks added are not shown</li>
<li>it starts much faster then earlier version</li>
</ul>
<p>You can't see more then 50 records since we've limited our view to 50 records. New tasks are added at the end of the store so at the positions 20000+. This is definitely way above range [0, 50) which is being shown.</p>
<p>Code at this stage can be found in the <code>todo_2_set_pagination</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-task-list"><a class="header" href="#updating-task-list">Updating task list</a></h1>
<p>All changes should happen in the <code>view/task_list.rs</code></p>
<p>In <code>relm4-store</code> components there is pagination component ready for you to use. Let's import it</p>
<pre><code class="language-rust noplaypen">use relm4::Components;
use relm4::RelmComponent;

use components::pagination::PaginationMsg;
use components::pagination::PaginationConfiguration;
use components::pagination::PaginationViewModel;

use store::StoreViewInnerComponent;
</code></pre>
<p>Now we need to add a component for the tasks list</p>
<pre><code class="language-rust noplaypen">pub struct TasksListComponents&lt;Config&gt;
where Config: TasksListConfiguration + 'static {
    pagination: RelmComponent&lt;PaginationViewModel&lt;Self&gt;, TasksListViewModel&lt;Config&gt;&gt;
}

impl&lt;Config&gt; Components&lt;TasksListViewModel&lt;Config&gt;&gt; for TasksListComponents&lt;Config&gt; 
where Config: TasksListConfiguration,
{
    fn init_components(
        parent_model: &amp;TasksListViewModel&lt;Config&gt;, 
        parent_sender: Sender&lt;&lt;TasksListViewModel&lt;Config&gt; as ViewModel&gt;::Msg&gt;
    ) -&gt; Self {
        Self {
            pagination: RelmComponent::new(parent_model, parent_sender.clone()),
        }
    }

    fn connect_parent(&amp;mut self, _parent_widgets: &amp;TasksListViewWidgets) {}
}

impl&lt;Config&gt; PaginationConfiguration for TasksListComponents&lt;Config&gt;
where Config: TasksListConfiguration + 'static {
    type StoreViewPrototype = TasksListViewModel&lt;Config&gt;;

    fn get_view(parent_view_model: &amp;&lt;Self::StoreViewPrototype as StoreViewPrototype&gt;::ViewModel) -&gt; View&lt;Self::StoreViewPrototype&gt; {
        parent_view_model.store_view.clone()
    }
}

impl&lt;Config&gt; StoreViewInnerComponent&lt;TasksListViewModel&lt;Config&gt;&gt; for TasksListComponents&lt;Config&gt;
where Config: TasksListConfiguration + 'static {
    fn on_store_update(&amp;mut self) {
        self.pagination.send(PaginationMsg::StoreUpdated).unwrap();
    }
}
</code></pre>
<p>TaskListComponent and pagination are normal relm4 components. For <code>TaskListComponent</code> we need to implement two extra traits. First is <code>PaginationConfiguration</code>. As name implies it provides configuration for pagination component. Second one and more interesting is <code>StoreViewInnerComponent</code>. This one provides a way to notify components when there is a change in the store. This allows to solve chicken and the egg problem of what's first store view or the pagination. Without view there is no point in pagination but pagination must own the view since it manages it.</p>
<p>Since we've created component for task list, now we need to add it to the <code>relm4::Model</code></p>
<pre><code class="language-rust noplaypen">impl&lt;Config&gt; ViewModel for TasksListViewModel&lt;Config&gt; 
where Config: TasksListConfiguration + 'static,
{
    type Msg = TaskMsg;
    type Widgets = TasksListViewWidgets;
    type Components = TasksListComponents&lt;Config&gt;;
}
</code></pre>
<p>What's left is to add bunch of <code>'static</code> lifetimes for <code>Config</code> generic attribute all around the file (compiler will tell you where). This is required because compiler can't infer the lifetime of some of the types.</p>
<p>Hopefully full list of the places to add <code>'static</code> lifetime:</p>
<ul>
<li>implementation of the <code>ViewModel for TaskListViewModel</code></li>
<li>implementation of the <code>StoreViewPrototype for TaskListViewModel</code></li>
<li>implementation of the <code>FactoryContainerWidget for TasksListViewWidgets</code></li>
</ul>
<p>Now let's put a cherry on top and add the pagination to the <code>TaskListViewWidgets</code>.</p>
<pre><code class="language-rust noplaypen">#[widget(visibility=pub, relm4=reexport::relm4)]
impl&lt;Config: TasksListConfiguration&gt; Widgets&lt;TasksListViewModel&lt;Config&gt;, Config::ParentViewModel&gt; for TasksListViewWidgets {
    view!{
        root = gtk::Box {
            set_margin_all: 12,
            set_orientation: gtk::Orientation::Vertical,
            append = &amp;gtk::Entry::with_buffer(&amp;model.new_task_description) {
                connect_activate(sender) =&gt; move |_| { 
                    send!(sender, TaskMsg::New); 
                } 
            },
            append = &amp;gtk::ScrolledWindow {
                set_hexpand: true,
                set_vexpand: true,
                set_child: container = Some(&amp;gtk::Box) {
                    set_orientation: gtk::Orientation::Vertical,
                    factory!(model.store_view)
                }
            },
            append: components.pagination.root_widget()
        }
    }
}
</code></pre>
<p>Last <code>append</code> adds pagination to the view.</p>
<p>This ends the story of adding pagination to the task list. Source code can be found in <code>todo_2</code> example</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<h2 id="etclog4rsyaml-1"><a class="header" href="#etclog4rsyaml-1"><code>etc/log4rs.yaml</code></a></h2>
<pre><code class="language-yaml"># Scan this file for changes every 30 seconds
refresh_rate: 30 seconds

appenders:
  # An appender named &quot;stdout&quot; that writes to stdout
  stdout:
    kind: console
    encoder:
      pattern: &quot;{h({l})} [ {f}:{L} ] {m}{n}&quot;

# Set the default logging level to &quot;warn&quot; and attach the &quot;stdout&quot; appender to the root
root:
  level: info
  appenders:
    - stdout

loggers:
  # Raise the maximum log level for events sent to the &quot;app::backend::db&quot; logger to &quot;info&quot;
  backend_inmemory::backend:
    level: trace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-view-window-behavior"><a class="header" href="#store-view-window-behavior">Store view window behavior</a></h1>
<p>In second chapter we've implemented a simple todo application with pagination. Now it's time to make pagination truly behave as we wish.</p>
<h2 id="goals-2"><a class="header" href="#goals-2">Goals</a></h2>
<ul>
<li>Define natural order of the store</li>
<li>Make the StoreView behave the way we would like it in the presence of the new data.</li>
</ul>
<p><a href="examples/03-todo/./01-ordering.html">Natural order</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ordering"><a class="header" href="#ordering">Ordering</a></h1>
<h2 id="natural-order"><a class="header" href="#natural-order">Natural order</a></h2>
<p>Natural order is the order in which your store returns data when no sorting is applied. The important thing to remember is if you implement your store
make sure natural order is stable. Otherwise to make your application useful either you would need to make sure you always apply sorting or you might
end up with application where every time interface is refreshed due to data changes being propagated, your whole ui shuffles. This will be terrible
from user point of view.</p>
<p>All examples until now we were using <code>InMemoryBackend</code> for which natural order is defined as order in which records where added. In this example we will switch to
<code>SortedInMemoryBackend</code> where we can change natural order of elements.</p>
<h2 id="sorting-behavior"><a class="header" href="#sorting-behavior">Sorting behavior</a></h2>
<p>There are two ways in which sorting work while you use data store. First is global sorting or natural order. You apply it to the store and store rebuilds itself so
natural order becomes the one which you had requested. This will cause update in all store views. Second way is to apply sorting to the store view.
This will make store view from now to ask the data to be ordered by the given property. Result seen by the view is equivalent of
<code>store view ordering(natural order(data))</code>.</p>
<p>If you define the ordering what was originally append at the end of the store might become insert somewhere in the middle of the data set. This might
lead to undesired side effects on the ui side. To give you power to decide what should happen you can use implementation of <code>store::window::WindowBehavior</code>.
By default in <code>relm4-store</code> there are implemented four kinds of window behaviors.</p>
<ol>
<li>PositionTrackingWindow</li>
<li>ValueTrackingWindow</li>
<li>KeepOnTop</li>
<li>KeepOnBottom</li>
</ol>
<h3 id="storewindowpositiontrackingwindow"><a class="header" href="#storewindowpositiontrackingwindow"><code>store::window::PositionTrackingWindow</code></a></h3>
<p>It keeps position of the view in the data store. So if you are showing records 5-10 you will always show records from 5-10 whatever they are. To understand
it better let's talk about it on examples.</p>
<p>All examples start with data store containing data <code>[0-&gt;a, 1-&gt;b, 2-&gt;c, 3-&gt;d, 4-&gt;e, 5-&gt;f, 6-&gt;g]</code>. Our view shows the range <code>[2, 5)</code> so user can see <code>[c, d, e]</code>.</p>
<p>If user inserts data at position before the range shown by the view for example at position <code>1 -&gt; a'</code> the data store then looks like
<code>[0-&gt;a, 1-&gt;a', 2-&gt;b, 3-&gt;c, 4-&gt;d, 5-&gt;e, 6-&gt;f, 7-&gt;g]</code>. View is expected to always show records from <code>[2, 5)</code> so view will be updated to user can see <code>[b, c, d]</code>.</p>
<p>If user inserts data inside the range <code>[2, 5)</code>. For example <code>3-&gt;c'</code> then ui will be updated so user can see <code>[c, c', d]</code>.</p>
<p>If user inserts at position <code>5</code> or higher ui will not be updated since there is nothing to do.</p>
<p>This kind of behavior works the best when you use some kind of pagination widget to navigate the data.</p>
<h3 id="storewindowvaluetrackingwindow"><a class="header" href="#storewindowvaluetrackingwindow"><code>store::window::ValueTrackingWindow</code></a></h3>
<p>This kind of window behavior tries to keep current data in the view as much as possible.</p>
<p>All examples start with data store containing data <code>[0-&gt;a, 1-&gt;b, 2-&gt;c, 3-&gt;d, 4-&gt;e, 5-&gt;f, 6-&gt;g]</code>. Our view shows the range <code>[2, 5)</code> so user can see <code>[c, d, e]</code>.</p>
<p>If you insert data at position before range start for example <code>1-&gt;a'</code> then position of the view will be adjusted to <code>[3, 6)</code> so data visible won't change.</p>
<p>If you insert data in the range then nothing we can do about data preservation. For example <code>3-&gt;c'</code> will end up as <code>[c, c', d]</code>.</p>
<p>If you insert data at position <code>5</code> or hight ui will not be updated and store view will still show the same range.</p>
<p>This kind of behavior works the best with scrolling. It makes interface feel more static then with <code>PositionTrackingWindow</code>. If you have a data generated at
the time user is seeing them and for some reason you can't use pagination this will be the best choice for you. Your users will scroll to the data they are
interested into and whatever happens to the data the view will try it's best to keep them in scope.</p>
<h3 id="storewindowkeeponbottom"><a class="header" href="#storewindowkeeponbottom"><code>store::window::KeepOnBottom</code></a></h3>
<p>Keeps the view at the certain distance from the end of data. This way if your sorting is stable in terms of adding new records users will see a log like view
of data.</p>
<p>All examples start with data store containing data <code>[0-&gt;a, 1-&gt;b, 2-&gt;c, 3-&gt;d, 4-&gt;e, 5-&gt;f, 6-&gt;g]</code>. Our view shows the range <code>[2, 5)</code> so user can see <code>[c, d, e]</code>.</p>
<p>If you add the record at <code>1-&gt;a'</code> then change would be ignored since distance from the end of the data did not change.</p>
<p>If you add the record inside the data range for example <code>3-&gt;c'</code> then the data store looks like <code>[0-&gt;a, 1-&gt;b, 2-&gt;c, 3-&gt;c', 4-&gt;d, 5-&gt;e, 6-&gt;f, 7-&gt;g]</code> this means that
keep the distance from the end we need to slide the window to the right so the range would be <code>[3, 6)</code> which in consequence show the user a data <code>[c', d, e]</code>.</p>
<p>If you add the record at position after the data range shown to the user, for example <code>7-&gt;h</code> to keep the distance from the end we need to slide the window to the
right so user would see <code>[d. e. f]</code>.</p>
<p>It's intended for log like views. It's useful in special cases.</p>
<h3 id="storewindowkeepontop"><a class="header" href="#storewindowkeepontop"><code>store::window::KeepOnTop</code></a></h3>
<p>It's reverse of <code>KeepOnBottom</code> where the distance kept is from the beginning of the data (from position <code>0</code>). It's another special case behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-sorting"><a class="header" href="#custom-sorting">Custom sorting</a></h1>
<p>In this example we will be working with natural order. This means we need to update the <code>Tasks</code> store. All changes will take place in the <code>store/tasks.rs</code>.</p>
<p>First we need to change our use statements so we can change backend to the <code>SortedInMemoryBackend</code> from</p>
<pre><code class="language-rust noplaypen">use backend_inmemory::InMemoryBackend;
use backend_inmemory::InMemoryBackendConfiguration;
use store::Store;

use crate::model::Task;
</code></pre>
<p>to</p>
<pre><code class="language-rust noplaypen">use backend_inmemory::SortedInMemoryBackend;
use backend_inmemory::SortedInMemoryBackendConfiguration;
use store::Sorter;
use store::Store;

use crate::model::Task;
</code></pre>
<p><code>SortedInMemoryBackend</code> gives an ability to change natural order of the elements in the store. <code>SortedInMemoryBackendConfiguration</code> is the trait describing
configuration of the sorted backend. It's expanded version of the <code>InMemoryBackendConfiguration</code> to also provide information about how elements should be ordered.
<code>Sorter</code> is the trait which implementation will decide what orders are available.</p>
<h2 id="implementing-sorter"><a class="header" href="#implementing-sorter">Implementing sorter</a></h2>
<p>This section is important. We will talk a lot about Rust and how to go around some of design decisions done by Rust developers.</p>
<p>In Rust you can implement <code>std::cmp::Ord</code> for your structure. This will define natural order of all instances of your structure. Now there is a problem what if there
is more then one natural order? For example sales transactions can be sorted by the date of creations, or they can be sorted by the amount in the month, or they can
be sorted by the customer and date. There is many many more ways to provide good and meaningful order to more complex values. Unfortunately standard library of Rust
doesn't allow such scenarios. So how we can solve it? There are two ways and both are in the terrible territory</p>
<ol>
<li>Break requirements of <code>std::cmp::Ord</code> implementation</li>
<li>Repeat the code</li>
</ol>
<p>Let's talk about first point, breaking <code>Ord</code>. To properly implement <code>Ord</code> you must define total order. But your implementation must be coffined to values provided by
the structure so either you need a way to update all the instances of your structure simultaneously so every two instances will be compared using same comparator and
constitute that way a total order or you end up with instances which can't be compared with each other in the safe way. Returning broken result from sorting is the
smallest issue here since the second choice can make some sorting algorithms fail into infinite loop. First option on the other hand is going to mess up your results
if you have more then one collection of your structures which needs to be in order. If you need to change order of the first collection and change the natural order
of your structure when you will add new element to your second collection you are screwed. So breaking <code>Ord</code> is bad.</p>
<p>Second choice is to use lambdas and write your own sorting strategy every time again and again. Repeating the code is bad that's truism. If your code needs to guarantee
the correct order of elements now you either end up writing your own wrapper around standard collections or repeatably write your sorting functions. If your sorting
is just a tiny bit more complex then comparing single field you will not like this idea. Searching for errors where by accident fields in order where swapped is no fun.</p>
<p><code>SortedInMemoryStore</code> is specialized collection which keeps ordering internal to the collection so it's not related to any data inside the sorted structure. So as long
as instance of <code>Sorter</code> constitutes the total order we can update order of elements just this in this store and it won't affect any other store of elements of the same
kind. Since it's relative to store we can implement as many sorting strategies as we like and swap them in the runtime.</p>
<h3 id="total-order"><a class="header" href="#total-order">Total order</a></h3>
<p>Until now I was total order this and total order that. So let's remind ourselves what it is. In simple words it means that for any two elements in the set you can
definitely say which one is smaller or wherever they are equal. In case of our <code>todo</code> application it means that for any two possible tasks (so not only ones we created,
but literally any possible tasks) we must provide an answer what is relationship between them.</p>
<p>If we would be talking about integers, or rational numbers, or real numbers, or texts that order is really natural. <code>1</code> is before <code>2</code>, <code>a</code> is before <code>b</code>, etc... Problem
arises when we start talking about more complex structures. For example complex numbers don't have this kind of natural order. It's possible to order them but it
requires providing a definition of how you would like to see them ordered. Examples can be:</p>
<ul>
<li>real part, imaginary part</li>
<li>imaginary part, real part</li>
<li>length, angle</li>
<li>angle, length</li>
</ul>
<p>And there is infinitely many more different orderings which are equally good. When you write your application the structures are often way more complex. So defining
good total order becomes harder and harder.</p>
<p>Now let's talk about math</p>
<ol>
<li>It's reflexive: <code>a &lt;= a</code></li>
<li>It's transitive: <code>If a &lt;= b and b &lt;= c then a &lt;= c</code></li>
<li>It's antisymmetric: <code>If a &lt;= b and b &lt;= a then a == b</code></li>
<li>It's total: For any <code>a</code> and <code>b</code> <code>a &lt;= b or b &lt;= a</code></li>
</ol>
<p><strong>Warning</strong> If you don't like the idea of being sad java programmer take this relationships seriously.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Let's stop talking and get to work</p>
<pre><code class="language-rust noplaypen">pub enum OrderTasksBy {
    Name{ascending: bool},
}

impl Sorter&lt;Task&gt; for OrderTasksBy {
    fn cmp(&amp;self, lhs: &amp;Task, rhs: &amp;Task) -&gt; std::cmp::Ordering {
        match self {
            OrderTasksBy::Name{ascending} =&gt; {
                if *ascending {
                    lhs.description.cmp(&amp;rhs.description)
                }
                else {
                    lhs.description.cmp(&amp;rhs.description).reverse()
                }
            },
        }
    }
}

pub type Tasks = Store&lt;SortedInMemoryBackend&lt;TasksBuilder&gt;&gt;;

pub struct TasksBuilder {}
</code></pre>
<p>As you see we've implemented <code>Sorter</code> for enumeration and not a structure. This way you can add the new ways of sorting as you see fit. Just remember to make sure that
for every case <code>cmp</code> method is total order.</p>
<p>Where is the issue in our implementation? Equality relationship. Two records are the same if they have a same id. But our implementation doesn't use that. If we would
be using it the total order would be broken. So as you can see inside of the store we are using two different definitions of what <code>equal</code> means.</p>
<p>The <code>SortedInMemoryBackend</code> is using <code>record id equality</code> to perform CRUD actions on record level. When we talk about order so which element is after which we use sorter
equality. That in itself can lead to the issues. What if I have a two instances of the record in the store one with the old value and second with new one?
<code>SortedInMemoryBackend</code> doesn't. So you are safe.</p>
<p>If we would implement some kind of store which keeps historic values of the record so you can do record based rollback it would add another level of thinking how to
handle all of that.</p>
<p>Any store backend implementation is a convenience tool but you must think and understand about how it works. Unfortunately at the current level of implementation
I don't see any way to make it one stop shop for you.</p>
<h2 id="backend"><a class="header" href="#backend">Backend</a></h2>
<p>Wherever we used <code>InMemoryBackend</code> or <code>InMemoryBackendConfiguration</code> earlier now we must use <code>SortedInMemoryBackend</code> and <code>SortedInMemoryBackendConfiguration</code>.</p>
<pre><code class="language-rust noplaypen">pub type Tasks = Store&lt;InMemoryBackend&lt;TasksBuilder&gt;&gt;;
</code></pre>
<p>becomes</p>
<pre><code class="language-rust noplaypen">pub type Tasks = Store&lt;SortedInMemoryBackend&lt;TasksBuilder&gt;&gt;;
</code></pre>
<p>and</p>
<pre><code class="language-rust noplaypen">impl InMemoryBackendConfiguration for TasksBuilder
</code></pre>
<p>becomes</p>
<pre><code class="language-rust noplaypen">impl SortedInMemoryBackendConfiguration for TasksBuilder
</code></pre>
<p>What's left is to update the implementation of the <code>SortedInMemoryBackendConfiguration</code> for <code>TaskBuilder</code></p>
<pre><code class="language-rust noplaypen">impl SortedInMemoryBackendConfiguration for TasksBuilder
{
    type Record = Task;
    type OrderBy = OrderTasksBy;

    fn initial_data() -&gt; Vec&lt;Self::Record&gt; {
        vec![
            Task::new(String::from(&quot;r&quot;), false),
            Task::new(String::from(&quot;f&quot;), false),
            Task::new(String::from(&quot;i&quot;), false),
            Task::new(String::from(&quot;c&quot;), false),
            Task::new(String::from(&quot;o&quot;), false),
            Task::new(String::from(&quot;y&quot;), false),
            Task::new(String::from(&quot;l&quot;), false),
            Task::new(String::from(&quot;u&quot;), false),
        ]
    }

    fn initial_order() -&gt; Self::OrderBy {
        OrderTasksBy::Name{ascending: true}
    }
}
</code></pre>
<p>First we've defined <code>OrderBy</code> type to be the implementation of the <code>Sorter</code>. This way our backend will know which sorter to use.</p>
<p>As you see I've reduced amount of records by creating them by hand as unordered bunch of tasks. When you open your application they will show up in ascending order.
Ease proof that we didn't make a mistake.</p>
<p>Last update is the <code>initial_order</code> method. We didn't use <code>Default</code> for the <code>OrderTaskBy</code> because there could be more then one instance of the <code>Tasks</code> store with
different configuration and different needs. Hard coding that into <code>Default</code> would be exactly what Rust designers did to make our life hard while implementing our own
version of the data store.</p>
<p>Whole code after this step can be found in examples <code>todo_3_sorted_store</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>Now we need an ability to toggle the order of tasks in the view. So we will add two buttons one to sort ascending and other one to sort descending.</p>
<p>Let's start with imports. We need to add</p>
<pre><code class="language-rust noplaypen">use gtk::prelude::ButtonExt;
use relm4::send;
use store::OrderedStore;

use crate::store::OrderTasksBy; 
</code></pre>
<p>Since we need to sort tasks we need to add new messages to the <code>MainWindowMsg</code>.</p>
<pre><code class="language-rust noplaypen">pub enum MainWindowMsg {
    ASC,
    DESC,
}
</code></pre>
<p>Now we need to handle new messages in the <code>update</code> method of the <code>MainWindowViewModel</code></p>
<pre><code class="language-rust noplaypen">impl AppUpdate for MainWindowViewModel {
    fn update(
        &amp;mut self, 
        msg: Self::Msg , 
        _components: &amp;Self::Components, 
        _sender: Sender&lt;Self::Msg&gt;
    ) -&gt; bool {
        match msg  {
            MainWindowMsg::ASC =&gt; {
                self.tasks.set_order(
                    OrderTasksBy::Name{ascending: true}
                )
            },
            MainWindowMsg::DESC =&gt; {
                self.tasks.set_order(
                    OrderTasksBy::Name{ascending: false}
                )
            }
        }

        true
    }
}
</code></pre>
<p><code>SortedInMemoryStore</code> implements <code>OrderedStore</code> which provides a method <code>set_order</code> which you can use to set order of elements in the store. Implementation of the
<code>set_order</code> will take care of propagating the knowledge about the changes to the store view and in consequence render it on the screen.</p>
<p>Only thing left it to update our <code>MainWindowWidgets</code> so it can send the messages to sort our view.</p>
<pre><code class="language-rust noplaypen">#[widget(visibility=pub, relm4=relm4)]
impl Widgets&lt;MainWindowViewModel, ()&gt; for MainWindowWidgets {
    view!{
        root = gtk::ApplicationWindow {
            set_child: Some(components.tasks_list.root_widget()),
            set_titlebar= Some(&amp;gtk::HeaderBar){
                set_title_widget = Some(&amp;gtk::Label::new(Some(&quot;todo_3&quot;))){},
                pack_end = &amp;gtk::Button::from_icon_name(&quot;view-sort-ascending-symbolic&quot;) {
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, MainWindowMsg::ASC)
                    },
                },
                pack_end = &amp;gtk::Button::from_icon_name(&quot;view-sort-descending-symbolic&quot;) {
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, MainWindowMsg::DESC)
                    },
                },
            },
            set_default_size: args!(350, 800),
        }
    }
}
</code></pre>
<p>To the titlebar of the main window we've added two buttons which will trigger sorting of the list. If you try adding new element to the list you will find that it's
being inserted accordingly to the state of the data store.</p>
<p>As always full code can be found in examples as <code>todo_3</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h1>
<h2 id="etclog4rsyaml-2"><a class="header" href="#etclog4rsyaml-2"><code>etc/log4rs.yaml</code></a></h2>
<pre><code class="language-yaml"># Scan this file for changes every 30 seconds
refresh_rate: 30 seconds

appenders:
  # An appender named &quot;stdout&quot; that writes to stdout
  stdout:
    kind: console
    encoder:
      pattern: &quot;{h({l})} [ {f}:{L} ] {m}{n}&quot;

# Set the default logging level to &quot;warn&quot; and attach the &quot;stdout&quot; appender to the root
root:
  level: info
  appenders:
    - stdout

loggers:
  # Raise the maximum log level for events sent to the &quot;app::backend::db&quot; logger to &quot;info&quot;
  backend_inmemory::backend:
    level: trace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removing-items-from-the-store"><a class="header" href="#removing-items-from-the-store">Removing items from the store</a></h1>
<p>We now know how to add and sort tasks in our todo application. Now comes the removal. We might add the task which is wrong or we no longer need the given task.
This makes removing the tasks a requirement.</p>
<h2 id="goals-3"><a class="header" href="#goals-3">Goals</a></h2>
<ul>
<li>We will add option to remove given record from the list of tasks</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view-1"><a class="header" href="#view-1">View</a></h1>
<p>We need to add a button with a trash to the right of our task description. When user presses the button we will remove the task from the store.</p>
<p>So in the <code>view/task_list.rs</code> we need to add imports</p>
<pre><code class="language-rust noplaypen">use gtk::Button;
use gtk::prelude::ButtonExt;
</code></pre>
<p>Then we need to update the <code>TaskWidgets</code> so they will hold reference to the delete button</p>
<pre><code class="language-rust noplaypen">
#[derive(Debug)]
#[allow(dead_code)]
pub struct TaskWidgets {
    checkbox: CheckButton,
    label: Label,
    delete_button: Button,
    root: Box,
</code></pre>
<p>We need to add <code>Delete</code> event to the <code>TaskMsg</code> so we can track which record should be deleted.</p>
<pre><code class="language-rust noplaypen">pub enum TaskMsg {
    Toggle{
        complete: bool,
        id: Id&lt;Task&gt;,
    },
    Delete(Id&lt;Task&gt;),
    New,
}
</code></pre>
<p>Now we need to update the <code>init_view</code> method in the implementation of the <code>StoreViewPrototype</code> for <code>TaskListViewModel</code></p>
<pre><code class="language-rust noplaypen">impl&lt;Config&gt; StoreViewPrototype for TasksListViewModel&lt;Config&gt; 
where Config: TasksListConfiguration + 'static,
{

    ...

    fn init_view(
        record: &amp;Task,
        _position: Position,
        sender: Sender&lt;TaskMsg&gt;,
    ) -&gt; Self::RecordWidgets {
        let root = Box::builder()
            .orientation(Orientation::Horizontal)
            .build();

        let checkbox = CheckButton::builder()
            .margin_top(12)
            .margin_start(12)
            .margin_end(12)
            .margin_bottom(12)
            .active(record.completed)
            .build();

        {
            let sender = sender.clone();
            let id = record.get_id();

            checkbox.connect_toggled(move |btn| {
                send!(sender, TaskMsg::Toggle{
                    id,
                    complete: btn.is_active()
                });
            });
        }

        let label = Label::builder()
            .margin_top(12)
            .margin_start(12)
            .margin_end(12)
            .margin_bottom(12)
            .label(&amp;record.description)
            .hexpand(true)
            .xalign(0.0)
            .build();

        let delete_button = Button::builder()
            .margin_top(12)
            .margin_start(12)
            .margin_end(12)
            .margin_bottom(12)
            .icon_name(&quot;user-trash-symbolic&quot;)
            .build();
            
        delete_button.add_css_class(&quot;flat&quot;);

        {
            let sender = sender.clone();
            let id = record.get_id();

            delete_button.connect_clicked(move |_| {
                send!(sender, TaskMsg::Delete(id));
            });
        }

        root.append(&amp;checkbox);
        root.append(&amp;label);
        root.append(&amp;delete_button);

        TaskWidgets {
            checkbox,
            label,
            delete_button,
            root,
        }
    }

    ...

}
</code></pre>
<p>The most important part is that we've built <code>delete_button</code> and added it to the <code>root</code> widget. When <code>delete_button</code> is clicked
it will send <code>TaskMsg::Delete</code>. To make ui nice we in the <code>label</code> we've added to extra settings</p>
<pre><code class="language-rust noplaypen">            .hexpand(true)
            .xalign(0.0)
</code></pre>
<p>This will expand horizontally and text will be left aligned.</p>
<p>Last thing left to do is to handle the changes in the <code>view</code> method in the implementation of <code>StoreViewPrototype</code> for <code>TaskListViewModel</code>.
Compiler will tell you exactly where.</p>
<pre><code class="language-rust noplaypen">impl&lt;Config&gt; StoreViewPrototype for TasksListViewModel&lt;Config&gt; 
where Config: TasksListConfiguration + 'static,
{

    ...

    fn update(
        view_model: &amp;mut Self::ViewModel, 
        msg: &lt;Self as ViewModel&gt;::Msg, 
        _sender: Sender&lt;&lt;Self as ViewModel&gt;::Msg&gt;
    ) {
        match msg {
            TaskMsg::New =&gt; {
                let description = view_model.new_task_description.text();
                let task = Task::new(description, false);
                view_model.new_task_description.set_text(&quot;&quot;);
                view_model.tasks.send(StoreMsg::Commit(task));
            },
            TaskMsg::Toggle{ complete, id } =&gt; {
                let tasks = &amp;view_model.tasks;
                if let Some(record) = tasks.get(&amp;id) {
                    let mut updated = record.clone();
                    updated.completed = complete;
                    tasks.send(StoreMsg::Commit(updated));
                }
            },
            TaskMsg::Delete(id) =&gt; {
                let tasks = &amp;view_model.tasks;
                tasks.send(StoreMsg::Delete(id));
            }
        }
    }

    ...

}
</code></pre>
<p>Sending <code>StorMsg::Delete</code> to the task with record id will remove it from the data store.</p>
<p>After this chapter you know how to <code>create</code>, <code>update</code> and <code>delete</code> the records from the store. Full source code can be found in the examples <code>todo_4</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h1>
<h2 id="etclog4rsyaml-3"><a class="header" href="#etclog4rsyaml-3"><code>etc/log4rs.yaml</code></a></h2>
<pre><code class="language-yaml"># Scan this file for changes every 30 seconds
refresh_rate: 30 seconds

appenders:
  # An appender named &quot;stdout&quot; that writes to stdout
  stdout:
    kind: console
    encoder:
      pattern: &quot;{h({l})} [ {f}:{L} ] {m}{n}&quot;

# Set the default logging level to &quot;warn&quot; and attach the &quot;stdout&quot; appender to the root
root:
  level: info
  appenders:
    - stdout

loggers:
  # Raise the maximum log level for events sent to the &quot;app::backend::db&quot; logger to &quot;info&quot;
  # backend_inmemory::backend:
  #   level: trace
  relm4_store_view_implementation:
    level: trace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releases"><a class="header" href="#releases">Releases</a></h1>
<h2 id="current-release"><a class="header" href="#current-release">Current release</a></h2>
<p>Current release version is <code>0.1-beta.2</code></p>
<p>On the release page you can find a migration guide from <code>0.1-beta.1</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-01-beta2"><a class="header" href="#release-01-beta2">Release 0.1-beta.2</a></h1>
<h2 id="release-status"><a class="header" href="#release-status">Release status</a></h2>
<p>Early beta</p>
<h2 id="changes"><a class="header" href="#changes">Changes</a></h2>
<ul>
<li><code>relm4</code> dependency got updated to <code>relm4-0.4.1</code> <a href="https://github.com/mskorkowski/relm4-store/issues/21">issue #21</a></li>
<li>Removing records from store <a href="https://github.com/mskorkowski/relm4-store/issues/14">issue #14</a></li>
<li><code>DataContainer</code> got moved into <code>relm4-store-collections</code> crate <a href="https://github.com/mskorkowski/relm4-store/issues/13">issue #13</a></li>
<li><code>DataContainer::invariants</code> are only run on the <code>dev/debug</code> releases <a href="https://github.com/mskorkowski/relm4-store/issues/27">issue #27</a></li>
<li>more unit tests</li>
</ul>
<p>This release was tracked under <a href="https://github.com/mskorkowski/relm4-store/issues/15">issue 0.1-beta.2</a></p>
<h2 id="migration-from-01-beta1-to-01-beta2"><a class="header" href="#migration-from-01-beta1-to-01-beta2">Migration from 0.1-beta.1 to 0.1-beta.2</a></h2>
<h3 id="storeviewprototype-1"><a class="header" href="#storeviewprototype-1">StoreViewPrototype</a></h3>
<p><code>relm4_store::StoreViewPrototype</code> methods got updated to follow <code>relm4::factory::FactoryPrototype</code></p>
<ul>
<li><code>generate</code> =&gt; <code>init_view</code></li>
<li><code>update_record</code> =&gt; <code>view</code></li>
<li><code>get_root</code> =&gt; <code>root_widget</code></li>
</ul>
<p>Full status of methods in <code>StoreViewPrototype</code></p>
<table><thead><tr><th align="left">0.1-beta.1 method name</th><th align="left">0.1-beta.2 method name</th><th align="left">reason</th></tr></thead><tbody>
<tr><td align="left">generate</td><td align="left">init_view</td><td align="left">follow <code>FactoryPrototype</code> update</td></tr>
<tr><td align="left">update_record</td><td align="left">view</td><td align="left">follow <code>FacroryPrototype</code> update</td></tr>
<tr><td align="left">get_root</td><td align="left">root_widget</td><td align="left">follow <code>FactoryPrototype</code> update</td></tr>
<tr><td align="left">position</td><td align="left">position</td><td align="left">not changed in <code>FactoryPrototype</code></td></tr>
<tr><td align="left">init_view_model</td><td align="left">init_view_model</td><td align="left">not changed, follows <code>ComponentUpdate</code></td></tr>
<tr><td align="left">update</td><td align="left">update</td><td align="left">not changed, follows <code>ComponentUpdate</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-01-beta1"><a class="header" href="#release-01-beta1">Release 0.1-beta.1</a></h1>
<p>It's first release ever. Early beta one.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
